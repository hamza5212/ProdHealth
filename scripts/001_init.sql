/* create tables for profiles, scans, products and basic indexes */
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  role text not null default 'user',
  created_at timestamp with time zone default now()
);

create table if not exists public.scans (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade,
  barcode text,
  product_name text,
  brand text,
  image_url text,
  nutrition_grade text,
  nova_group int,
  score int,
  created_at timestamp with time zone default now()
);

create table if not exists public.products (
  id bigint generated by default as identity primary key,
  barcode text unique,
  name text,
  brand text,
  from_off boolean default false,
  modified_by uuid references auth.users(id),
  updated_at timestamp with time zone default now()
);

-- Helpful indexes
create index if not exists scans_user_id_idx on public.scans(user_id);
create index if not exists scans_created_at_idx on public.scans(created_at desc);

-- Enable RLS
alter table public.profiles enable row level security;
alter table public.scans enable row level security;
alter table public.products enable row level security;

-- Policies
do $$
begin
  if not exists (select 1 from pg_policies where polname = 'profiles_self') then
    create policy profiles_self on public.profiles
      for all using (id = auth.uid()) with check (id = auth.uid());
  end if;

  if not exists (select 1 from pg_policies where polname = 'scans_owner') then
    create policy scans_owner on public.scans
      for select using (user_id = auth.uid());
    create policy scans_insert on public.scans
      for insert with check (user_id = auth.uid());
  end if;

  if not exists (select 1 from pg_policies where polname = 'products_readall') then
    create policy products_readall on public.products
      for select using (true);
  end if;

  if not exists (select 1 from pg_policies where polname = 'products_admin_write') then
    create policy products_admin_write on public.products
      for all using (auth.jwt() ->> 'role' = 'admin') with check (auth.jwt() ->> 'role' = 'admin');
  end if;
end $$;

-- Optional initial profile upsert function
create or replace function public.ensure_profile()
returns void
language plpgsql
security definer
as $$
begin
  insert into public.profiles (id, role)
  values (auth.uid(), coalesce((auth.jwt() ->> 'role')::text, 'user'))
  on conflict (id) do update set role = excluded.role;
end;
$$;
