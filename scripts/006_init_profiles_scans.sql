-- 1) PROFILES TABLE
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  preferences jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Ensure preferences column exists (if table pre-existed without it)
do $$
begin
  if not exists (
    select 1
    from information_schema.columns
    where table_schema = 'public'
      and table_name = 'profiles'
      and column_name = 'preferences'
  ) then
    alter table public.profiles
      add column preferences jsonb not null default '{}'::jsonb;
  end if;
end$$;

-- Updated_at trigger
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at := now();
  return new;
end;
$$;

drop trigger if exists profiles_set_updated_at on public.profiles;
create trigger profiles_set_updated_at
before update on public.profiles
for each row execute function public.set_updated_at();

-- Enable RLS + policies
alter table public.profiles enable row level security;

-- Drop and recreate owner policies to be idempotent
drop policy if exists profiles_owner_select on public.profiles;
drop policy if exists profiles_owner_insert on public.profiles;
drop policy if exists profiles_owner_update on public.profiles;

create policy profiles_owner_select
  on public.profiles
  for select
  using (auth.uid() = id);

create policy profiles_owner_insert
  on public.profiles
  for insert
  with check (auth.uid() = id);

create policy profiles_owner_update
  on public.profiles
  for update
  using (auth.uid() = id)
  with check (auth.uid() = id);

-- 2) SCANS TABLE
create table if not exists public.scans (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  barcode text not null,
  product_name text,
  brand text,
  nutrition jsonb,
  created_at timestamptz not null default now()
);

-- Helpful indexes for common queries
create index if not exists idx_scans_user_id on public.scans(user_id);
create index if not exists idx_scans_user_id_created_at on public.scans(user_id, created_at desc);

-- Enable RLS + owner-only policies
alter table public.scans enable row level security;

drop policy if exists scans_owner_select on public.scans;
drop policy if exists scans_owner_insert on public.scans;
drop policy if exists scans_owner_update on public.scans;
drop policy if exists scans_owner_delete on public.scans;

create policy scans_owner_select
  on public.scans
  for select
  using (auth.uid() = user_id);

create policy scans_owner_insert
  on public.scans
  for insert
  with check (auth.uid() = user_id);

create policy scans_owner_update
  on public.scans
  for update
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy scans_owner_delete
  on public.scans
  for delete
  using (auth.uid() = user_id);

-- 3) AUTO-CREATE PROFILE FOR NEW AUTH USERS
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles (id)
  values (new.id)
  on conflict (id) do nothing;
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.handle_new_user();

-- 4) Ask PostgREST to reload its schema cache (helps clear PGRST205 quickly)
-- This is safe; if postgrest is not listening, itâ€™s a no-op.
do $$
begin
  perform pg_notify('pgrst', 'reload schema');
exception
  when others then
    -- ignore; not all environments allow notify
    null;
end$$;
